// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");

function observe(operation, source) {
  Curry._1(source, /* Start */Block.__(0, [(function (t) {
              if (typeof t === "number" || !t.tag) {
                return /* () */0;
              } else {
                return Curry._1(operation, t[0]);
              }
            })]));
  return /* () */0;
}

function interval(period, _type) {
  var timeoutId = [/* None */0];
  var $$continue = [/* true */1];
  if (typeof _type === "number") {
    return /* () */0;
  } else if (_type.tag) {
    return /* () */0;
  } else {
    var sink = _type[0];
    var startInterval = function (num, callbag) {
      timeoutId[0] = /* Some */[setTimeout((function () {
                Curry._1(callbag, /* Data */Block.__(1, [num]));
                if ($$continue[0]) {
                  return startInterval(num + 1 | 0, callbag);
                } else {
                  return 0;
                }
              }), period)];
      return /* () */0;
    };
    Curry._1(sink, /* Start */Block.__(0, [(function (_type) {
                if (typeof _type === "number") {
                  var match = timeoutId[0];
                  if (match) {
                    clearTimeout(match[0]);
                    $$continue[0] = /* false */0;
                    return /* () */0;
                  } else {
                    return /* () */0;
                  }
                } else {
                  return /* () */0;
                }
              })]));
    startInterval(0, sink);
    return /* () */0;
  }
}

function take(max, source, start) {
  if (typeof start === "number") {
    return /* () */0;
  } else if (start.tag) {
    return /* () */0;
  } else {
    var sink = start[0];
    var taken = [0];
    var sourceTalkback = [/* None */0];
    var talkback = function (_type) {
      var match = sourceTalkback[0];
      if (match && taken[0] < max) {
        return Curry._1(match[0], _type);
      } else {
        return /* () */0;
      }
    };
    return Curry._1(source, /* Start */Block.__(0, [(function (_type) {
                      if (typeof _type === "number") {
                        return Curry._1(sink, _type);
                      } else if (_type.tag) {
                        taken[0] = taken[0] + 1 | 0;
                        Curry._1(sink, /* Data */Block.__(1, [_type[0]]));
                        if (taken[0] === max) {
                          Curry._1(sink, /* End */0);
                          var match = sourceTalkback[0];
                          if (match) {
                            return Curry._1(match[0], /* End */0);
                          } else {
                            return /* () */0;
                          }
                        } else {
                          return 0;
                        }
                      } else {
                        sourceTalkback[0] = /* Some */[_type[0]];
                        return Curry._1(sink, /* Start */Block.__(0, [talkback]));
                      }
                    })]));
  }
}

observe((function (d) {
        console.log(d);
        return /* () */0;
      }), (function (param) {
        return take(2, (function (param) {
                      return interval(1000, param);
                    }), param);
      }));

exports.observe  = observe;
exports.interval = interval;
exports.take     = take;
/*  Not a pure module */
